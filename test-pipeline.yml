# Test pipeline with real F# build - single job, single configuration
trigger: none

pr:
  branches:
    include:
    - main
  paths:
    include:
    - '*'

variables:
  - name: _TeamName
    value: FSharpTest
  - name: _BuildConfig
    value: Release
  - name: _TestKind
    value: testCoreclr
  # Safety check - only run on fork
  - name: IsTestFork
    value: ${{ contains(variables['Build.Repository.Name'], 'abonie') }}

stages:
- stage: build
  displayName: Build
  jobs:

  # Real F# build job - simplified to single configuration
  - job: WindowsCompressedMetadata
    displayName: 'Windows Tests (Compressed Metadata) - CoreCLR'
    pool:
      #vmImage: 'windows-2022'  # Use Windows 2022 for latest tools
      name: 'NetCore-Public'
      demands: ImageOverride -equals 'Windows.vs2022.amd64.open'
    timeoutInMinutes: 60
    variables:
    - name: XUNIT_LOGS
      value: $(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)
    - name: __VSNeverShowWhatsNew
      value: 1
    steps:
    - checkout: self
      clean: true

    # Set up .NET SDK (matching your real pipeline)
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: sdk
        version: '10.x'  # Or whatever version F# currently uses
        includePreviewVersions: true
        workingDirectory: $(Build.SourcesDirectory)
        installationPath: $(Build.SourcesDirectory)/.dotnet

    # Initialize dotnet (from your real pipeline)
    - script: .\eng\common\dotnet.cmd
      displayName: 'Initialize dotnet'
      workingDirectory: $(Build.SourcesDirectory)

    - powershell: eng\SetupVSHive.ps1
      displayName: Setup VS Hive
      condition: eq(variables.setupVsHive, 'true')

    # Run the actual F# build with compressed metadata and CoreCLR tests
    - script: .\eng\CIBuildNoPublish.cmd -compressallmetadata -configuration $(_BuildConfig) -$(_TestKind)

    # Publish the real test results generated by F# test suite
    - task: PublishTestResults@2
      displayName: 'Publish F# Test Results'
      inputs:
        testResultsFormat: 'XUnit'
        testRunTitle: 'WindowsCompressedMetadata $(_TestKind)'
        mergeTestResults: true
        testResultsFiles: '*.xml'
        searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
      continueOnError: true
      condition: succeededOrFailed()

    # Publish build logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Logs'
      condition: always()
      continueOnError: true
      inputs:
        PathToPublish: '$(Build.SourcesDirectory)\artifacts\log\$(_BuildConfig)'
        ArtifactName: 'F# Build Logs $(_TestKind)'
        ArtifactType: Container

    # Publish test logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Test Logs'
      inputs:
        PathtoPublish: '$(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)'
        ArtifactName: 'F# Test Logs $(_TestKind)'
        publishLocation: Container
      continueOnError: true
      condition: always()

# Test the failure reporting functionality with real F# failures
- stage: report_failures
  displayName: Report Build and Test Failures
  dependsOn: build
  condition: and(
    always(),
    eq(variables['Build.Reason'], 'PullRequest'),
    eq(variables['IsTestFork'], true),
    or(
      eq(dependencies.build.result, 'Failed'),
      eq(dependencies.build.result, 'SucceededWithIssues')
    ))
  jobs:
  - job: CollectAndReportFailures
    displayName: 'Test Failure Reporting Script'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # Enable OAuth token access for checkout
    - checkout: self

    # Debug: Show what we're working with
    - task: PowerShell@2
      displayName: 'Debug: Pipeline Context'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Pipeline Context for Real F# Build:"
          Write-Host "  Build ID: $(Build.BuildId)"
          Write-Host "  Organization: $(System.TeamFoundationCollectionUri)"
          Write-Host "  Project: $(System.TeamProject)"
          Write-Host "  Repository: $(Build.Repository.Name)"
          Write-Host "  PR Number: $(System.PullRequest.PullRequestNumber)"
          Write-Host "  Build Reason: $(Build.Reason)"
          Write-Host "  Configuration: $(_BuildConfig)"
          Write-Host "  Test Kind: $(_TestKind)"
        pwsh: true

    # Test the actual script with real F# build data
    - task: PowerShell@2
      displayName: 'Run Report-BuildFailures Script'
      inputs:
        filePath: '$(Build.SourcesDirectory)/eng/scripts/Report-BuildFailures.ps1'
        arguments: >-
          -BuildId $(Build.BuildId)
          -Organization "$(System.TeamFoundationCollectionUri)"
          -Project "$(System.TeamProject)"
          -GitHubToken "test-token-for-now"
          -Repository "$(Build.Repository.Name)"
          -PullRequestId $(System.PullRequest.PullRequestNumber)
        pwsh: true
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
      condition: always()
      continueOnError: true
