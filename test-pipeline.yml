# Test pipeline with real F# build - single job, single configuration
trigger: none

pr:
  branches:
    include:
    - main
  paths:
    include:
    - '*'

variables:
  - name: _TeamName
    value: FSharpTest
  - name: _BuildConfig
    value: Release
  - name: _TestKind
    value: testCoreclr
  # Safety check - only run on fork
  - name: IsTestFork
    value: ${{ contains(variables['Build.Repository.Name'], 'abonie') }}

stages:
- stage: build
  displayName: Build
  jobs:

  # Real F# build job - simplified to single configuration
  - job: WindowsCompressedMetadata
    displayName: 'Windows Tests (Compressed Metadata) - CoreCLR'
    pool:
      vmImage: 'windows-latest'
    timeoutInMinutes: 60
    variables:
    - name: XUNIT_LOGS
      value: $(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)
    - name: __VSNeverShowWhatsNew
      value: 1
    steps:
    - checkout: self
      clean: true

    # Set up .NET SDK (matching your real pipeline)
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: sdk
        version: '10.x'  # Or whatever version F# currently uses
        includePreviewVersions: true
        workingDirectory: $(Build.SourcesDirectory)
        installationPath: $(Build.SourcesDirectory)/.dotnet

    # Initialize dotnet (from your real pipeline)
    - script: .\eng\common\dotnet.cmd
      displayName: 'Initialize dotnet'
      workingDirectory: $(Build.SourcesDirectory)

    # Run the actual F# build with compressed metadata and CoreCLR tests
    - script: .\eng\CIBuildNoPublish.cmd -noVisualStudio -compressallmetadata -configuration $(_BuildConfig) -$(_TestKind)

    # Publish the real test results generated by F# test suite
    - task: PublishTestResults@2
      displayName: 'Publish F# Test Results'
      inputs:
        testResultsFormat: 'XUnit'
        testRunTitle: 'WindowsCompressedMetadata $(_TestKind)'
        mergeTestResults: true
        testResultsFiles: '*.xml'
        searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
      continueOnError: true
      condition: succeededOrFailed()

    # Publish build logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Logs'
      condition: always()
      continueOnError: true
      inputs:
        PathToPublish: '$(Build.SourcesDirectory)\artifacts\log\$(_BuildConfig)'
        ArtifactName: 'F# Build Logs $(_TestKind)'
        ArtifactType: Container

    # Publish test logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Test Logs'
      inputs:
        PathtoPublish: '$(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)'
        ArtifactName: 'F# Test Logs $(_TestKind)'
        publishLocation: Container
      continueOnError: true
      condition: always()

# Test the failure reporting functionality with real F# failures
- stage: report_failures
  displayName: Report Build and Test Failures
  dependsOn: build
  condition: and(
    always(),
    eq(variables['Build.Reason'], 'PullRequest'),
    eq(variables['IsTestFork'], true),
    or(
      eq(dependencies.build.result, 'Failed'),
      eq(dependencies.build.result, 'SucceededWithIssues')
    ))
  jobs:
  - job: CollectAndReportFailures
    displayName: 'Test Failure Reporting Script'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # Enable OAuth token access for checkout
    - checkout: self

    # Check if PR assignee is allowed to receive failure reports
    - task: PowerShell@2
      displayName: 'Check PR Assignee'
      name: 'CheckAssignee'
      inputs:
        targetType: 'inline'
        script: |
          $allowedAssignees = @('abonie', 'copilot')
          $shouldRunReport = $false

          try {
            $prNumber = "$(System.PullRequest.PullRequestNumber)"
            $repoName = "$(Build.Repository.Name)"

            if ([string]::IsNullOrEmpty($prNumber) -or [string]::IsNullOrEmpty($repoName)) {
              Write-Host "⚠️ Missing PR number or repository name, skipping assignee check"
              Write-Host "##vso[task.setvariable variable=shouldRunReport;isOutput=true]false"
              exit 0
            }

            # Get PR details from GitHub API
            $headers = @{
              'Authorization' = "token $env:GITHUB_TOKEN"
              'Accept' = 'application/vnd.github.v3+json'
              'User-Agent' = 'Azure-DevOps-Build-Reporter'
            }

            $prUrl = "https://api.github.com/repos/$repoName/pulls/$prNumber"
            Write-Host "🔍 Checking PR assignee for: $prUrl"

            $prData = Invoke-RestMethod -Uri $prUrl -Headers $headers -Method Get

            # Check multiple assignees (modern field only)
            $assigneeLogins = @()

            if ($prData.assignees -and $prData.assignees.Count -gt 0) {
              $assigneeLogins = $prData.assignees | ForEach-Object { $_.login }
            }

            if ($assigneeLogins.Count -gt 0) {
              Write-Host "👤 PR assignee(s): $($assigneeLogins -join ', ')"

              # Check if any assignee is in the allowed list
              $allowedAssignee = $assigneeLogins | Where-Object { $_ -in $allowedAssignees } | Select-Object -First 1

              if ($allowedAssignee) {
                Write-Host "✅ Failure report will be generated (found allowed assignee: '$allowedAssignee')"
                $shouldRunReport = $true
              } else {
                Write-Host "❌ No allowed assignees found. Assignees: $($assigneeLogins -join ', ')"
              }
            } else {
              Write-Host "ℹ️ PR has no assignees, skipping failure report"
            }
          }
          catch {
            Write-Warning "❌ Failed to check PR assignee: $($_.Exception.Message)"
            Write-Host "Setting shouldRunReport to false due to error"
          }

          Write-Host "##vso[task.setvariable variable=shouldRunReport;isOutput=true]$shouldRunReport"
          Write-Host "Final decision: shouldRunReport = $shouldRunReport"
        pwsh: true
      env:
        GITHUB_TOKEN: $(github-pat)
      continueOnError: true

    # Debug: Show what we're working with
    - task: PowerShell@2
      displayName: 'Debug: Pipeline Context'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Pipeline Context for Real F# Build:"
          Write-Host "  Build ID: $(Build.BuildId)"
          Write-Host "  Organization: $(System.TeamFoundationCollectionUri)"
          Write-Host "  Project: $(System.TeamProject)"
          Write-Host "  Repository: $(Build.Repository.Name)"
          Write-Host "  PR Number: $(System.PullRequest.PullRequestNumber)"
          Write-Host "  Build Reason: $(Build.Reason)"
          Write-Host "  Configuration: $(_BuildConfig)"
          Write-Host "  Test Kind: $(_TestKind)"
          Write-Host "  Should Run Report: $(CheckAssignee.shouldRunReport)"
        pwsh: true

    # Test the actual script with real F# build data
    - task: PowerShell@2
      displayName: 'Run Report-BuildFailures Script'
      inputs:
        filePath: '$(Build.SourcesDirectory)/eng/scripts/Report-BuildFailures.ps1'
        arguments: >-
          -BuildId $(Build.BuildId)
          -Organization "$(System.CollectionUri)"
          -Project "$(System.TeamProject)"
          -Repository "$(Build.Repository.Name)"
          -PullRequestId $(System.PullRequest.PullRequestNumber)
        pwsh: true
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
        GITHUB_TOKEN: $(github-pat)
      condition: and(always(), eq(variables['CheckAssignee.shouldRunReport'], 'true'))
      continueOnError: true
