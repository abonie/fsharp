# Test pipeline with real F# build - single job, single configuration
trigger: none

pr:
  branches:
    include:
    - main
  paths:
    include:
    - '*'

variables:
  - name: _TeamName
    value: FSharpTest
  - name: _BuildConfig
    value: Release
  - name: _TestKind
    value: testCoreclr
  # Safety check - only run on fork
  - name: IsTestFork
    value: ${{ contains(variables['Build.Repository.Name'], 'abonie') }}

stages:
- stage: build
  displayName: Build
  jobs:

  # Real F# build job - simplified to single configuration
  - job: WindowsCompressedMetadata
    displayName: 'Windows Tests (Compressed Metadata) - CoreCLR'
    pool:
      vmImage: 'windows-latest'
    timeoutInMinutes: 60
    variables:
    - name: XUNIT_LOGS
      value: $(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)
    - name: __VSNeverShowWhatsNew
      value: 1
    steps:
    - checkout: self
      clean: true

    # Clean up disk space by removing unnecessary folders
    - task: PowerShell@2
      displayName: 'Clean up disk space'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Disk space before cleanup:"
          Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, @{Name="Size(GB)";Expression={[math]::Round($_.Size/1GB,2)}}, @{Name="FreeSpace(GB)";Expression={[math]::Round($_.FreeSpace/1GB,2)}}, @{Name="PercentFree";Expression={[math]::Round(($_.FreeSpace/$_.Size)*100,2)}} | Format-Table -AutoSize

          Write-Host "Removing Android SDK and Java folders to free up space..."

          # Remove Android SDK
          $androidPath = "${env:ANDROID_HOME}"
          if ($androidPath -and (Test-Path $androidPath)) {
            Write-Host "Removing Android SDK from: $androidPath"
            Remove-Item -Path $androidPath -Recurse -Force -ErrorAction SilentlyContinue
          }

          # Remove additional Android paths
          $androidPaths = @(
            "${env:ANDROID_SDK_ROOT}",
            "${env:ProgramFiles(x86)}\Android",
            "${env:ProgramData}\Microsoft\AndroidSDK"
          )
          foreach ($path in $androidPaths) {
            if ($path -and (Test-Path $path)) {
              Write-Host "Removing Android folder: $path"
              Remove-Item -Path $path -Recurse -Force -ErrorAction SilentlyContinue
            }
          }

          # Remove Java installations
          $javaPaths = @(
            "${env:JAVA_HOME}",
            "${env:ProgramFiles}\Java",
            "${env:ProgramFiles(x86)}\Java"
          )
          foreach ($path in $javaPaths) {
            if ($path -and (Test-Path $path)) {
              Write-Host "Removing Java folder: $path"
              Remove-Item -Path $path -Recurse -Force -ErrorAction SilentlyContinue
            }
          }

          Write-Host "Cleanup completed!"
          Write-Host "Disk space after cleanup:"
          Get-WmiObject -Class Win32_LogicalDisk | Select-Object DeviceID, @{Name="Size(GB)";Expression={[math]::Round($_.Size/1GB,2)}}, @{Name="FreeSpace(GB)";Expression={[math]::Round($_.FreeSpace/1GB,2)}}, @{Name="PercentFree";Expression={[math]::Round(($_.FreeSpace/$_.Size)*100,2)}} | Format-Table -AutoSize
        pwsh: true
      continueOnError: true

    # Set up .NET SDK (matching your real pipeline)
    - task: UseDotNet@2
      displayName: 'Install .NET SDK'
      inputs:
        packageType: sdk
        version: '10.x'  # Or whatever version F# currently uses
        includePreviewVersions: true
        workingDirectory: $(Build.SourcesDirectory)
        installationPath: $(Build.SourcesDirectory)/.dotnet

    # Initialize dotnet (from your real pipeline)
    - script: .\eng\common\dotnet.cmd
      displayName: 'Initialize dotnet'
      workingDirectory: $(Build.SourcesDirectory)

    - powershell: eng\SetupVSHive.ps1
      displayName: Setup VS Hive
      condition: eq(variables.setupVsHive, 'true')

    # Run the actual F# build with compressed metadata and CoreCLR tests
    - script: .\eng\CIBuildNoPublish.cmd -compressallmetadata -configuration $(_BuildConfig) -$(_TestKind)

    # Publish the real test results generated by F# test suite
    - task: PublishTestResults@2
      displayName: 'Publish F# Test Results'
      inputs:
        testResultsFormat: 'XUnit'
        testRunTitle: 'WindowsCompressedMetadata $(_TestKind)'
        mergeTestResults: true
        testResultsFiles: '*.xml'
        searchFolder: '$(Build.SourcesDirectory)/artifacts/TestResults/$(_BuildConfig)'
      continueOnError: true
      condition: succeededOrFailed()

    # Publish build logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Build Logs'
      condition: always()
      continueOnError: true
      inputs:
        PathToPublish: '$(Build.SourcesDirectory)\artifacts\log\$(_BuildConfig)'
        ArtifactName: 'F# Build Logs $(_TestKind)'
        ArtifactType: Container

    # Publish test logs for debugging (optional)
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Test Logs'
      inputs:
        PathtoPublish: '$(Build.SourcesDirectory)\artifacts\TestResults\$(_BuildConfig)'
        ArtifactName: 'F# Test Logs $(_TestKind)'
        publishLocation: Container
      continueOnError: true
      condition: always()

# Test the failure reporting functionality with real F# failures
- stage: report_failures
  displayName: Report Build and Test Failures
  dependsOn: build
  condition: and(
    always(),
    eq(variables['Build.Reason'], 'PullRequest'),
    eq(variables['IsTestFork'], true),
    or(
      eq(dependencies.build.result, 'Failed'),
      eq(dependencies.build.result, 'SucceededWithIssues')
    ))
  jobs:
  - job: CollectAndReportFailures
    displayName: 'Test Failure Reporting Script'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    # Enable OAuth token access for checkout
    - checkout: self

    # Debug: Show what we're working with
    - task: PowerShell@2
      displayName: 'Debug: Pipeline Context'
      inputs:
        targetType: 'inline'
        script: |
          Write-Host "Pipeline Context for Real F# Build:"
          Write-Host "  Build ID: $(Build.BuildId)"
          Write-Host "  Organization: $(System.TeamFoundationCollectionUri)"
          Write-Host "  Project: $(System.TeamProject)"
          Write-Host "  Repository: $(Build.Repository.Name)"
          Write-Host "  PR Number: $(System.PullRequest.PullRequestNumber)"
          Write-Host "  Build Reason: $(Build.Reason)"
          Write-Host "  Configuration: $(_BuildConfig)"
          Write-Host "  Test Kind: $(_TestKind)"
        pwsh: true

    # Test the actual script with real F# build data
    - task: PowerShell@2
      displayName: 'Run Report-BuildFailures Script'
      inputs:
        filePath: '$(Build.SourcesDirectory)/eng/scripts/Report-BuildFailures.ps1'
        arguments: >-
          -BuildId $(Build.BuildId)
          -Organization "$(System.TeamFoundationCollectionUri)"
          -Project "$(System.TeamProject)"
          -GitHubToken "test-token-for-now"
          -Repository "$(Build.Repository.Name)"
          -PullRequestId $(System.PullRequest.PullRequestNumber)
        pwsh: true
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
      condition: always()
      continueOnError: true
